/*  axi_m_epc.c - The simplest kernel module.
 */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/mm.h>
#include <linux/types.h>
#include <asm/io.h>


#define AXI_EPC_0_BASEADDR 0x40600000U
#define AXI_EPC_0_LENGTH   0x20000U

#define DRIVER_NAME "XiImage"

#define AXI_EPC_WRITE  1
#define AXI_EPC_READ   2<<1
struct AXI_EPC_DATA{
    unsigned int reg;
    unsigned int data;
};

struct image_dev {
    struct device *dev;
    struct cdev cdev;
    struct class *cls;
};


#define PICTURENAME "XiPicture"
#define AXINAME  "AxiConfig"


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("zestroly@126.com Inc.");
MODULE_DESCRIPTION("image - loadable module template generated by petalinux-create -t modules");

static struct image_dev *pictureDev = NULL;
static int majorPicture = 0;
static int minorPicture = 0;
#define PICTUREBASEADDR 0x1E000000


static struct image_dev *AxiDev = NULL;
static int majorAxi = 0;
static int minorAxi = 0;
#define AXIBASEADDR 0x40600000


static int pictureDev_open(struct inode *inode, struct file *file)
{
	return 0;
}

static int pictureDev_close(struct inode *inode, struct file *file)
{
    return 0;
}

static int pictureDev_mmap(struct file *file, struct vm_area_struct *vma)
{
    vma->vm_flags |= (VM_IO);
    //| VM_DONTEXPAND | VM_DONTDUMP);

    vma->vm_page_prot=pgprot_noncached(vma->vm_page_prot);
    if(remap_pfn_range(vma,//虚拟内存区域
                vma->vm_start, //虚拟内存起始地址
                (PICTUREBASEADDR>>PAGE_SHIFT),//映射区域大小，一般是页大小的倍数
                vma->vm_end - vma->vm_start,
                vma->vm_page_prot))//保护属性
    {
        printk("[kernel] error:axi address mmap failure!\n");
        return -EAGAIN;
    }
    return 0;
}


static struct file_operations pictureDev_fops = {
    .owner = THIS_MODULE,
    .open = pictureDev_open,
    .release = pictureDev_close,
    .mmap = pictureDev_mmap,
};

static int init_picture(void )
{
    int retval;
    dev_t dev_id;

    if (majorPicture) {
        dev_id = MKDEV(majorPicture, minorPicture);
        retval = register_chrdev_region(dev_id, 1, "XiPicture");
    } else {
        retval = alloc_chrdev_region(&dev_id, 0, 1, "XiPicture");
        majorPicture = MAJOR(dev_id);
    }
    if (retval < 0) {
        goto failure_register_device;
    }

    pictureDev = kmalloc(sizeof(struct image_dev), GFP_KERNEL);
    if (IS_ERR(pictureDev)) {
        retval = PTR_ERR(pictureDev);
        goto failure_kmalloc;
    }
    memset(pictureDev, 0, sizeof(struct image_dev));

    cdev_init(&pictureDev->cdev, &pictureDev_fops);
    retval = cdev_add(&pictureDev->cdev, dev_id, 1);
    if (retval < 0) {
        goto failure_cdev_add;
    }

    pictureDev->cls = class_create(THIS_MODULE, "XiPicture");
    if (IS_ERR(pictureDev->cls)) {
        retval = PTR_ERR(pictureDev->cls);
        goto failure_create_class;
    }

    pictureDev->dev = device_create(pictureDev->cls, NULL, dev_id, NULL, "Xipicture");
    if (IS_ERR(pictureDev->dev)) {
        retval = PTR_ERR(pictureDev->dev);
        goto failure_create_device;
    }

    printk("[kernel] init XiPicture module ok!\n");
    return 0;

failure_create_device:
    class_destroy(pictureDev->cls);
failure_create_class:
    cdev_del(&pictureDev->cdev);
failure_cdev_add:
    kfree(pictureDev);
    pictureDev = NULL;
failure_kmalloc:
    unregister_chrdev_region(dev_id, 1);
failure_register_device:
    return retval;
}


static int exit_picture(void )
{
    dev_t dev_id = MKDEV(majorPicture, minorPicture);
    device_destroy(pictureDev->cls, dev_id);
    class_destroy(pictureDev->cls);
    cdev_del(&pictureDev->cdev);
    kfree(pictureDev);
    unregister_chrdev_region(dev_id, 1);
    printk("[kernel] remove XiPicture module ok!\n");
    return 0;
}









/* ***************************************************************88*/

static int AxiDev_open(struct inode *inode, struct file *file)
{
	return 0;
}

static int AxiDev_close(struct inode *inode, struct file *file)
{
    return 0;
}




static int AxiDev_mmap(struct file *file, struct vm_area_struct *vma)
{
    vma->vm_flags |= (VM_IO);
    //| VM_DONTEXPAND | VM_DONTDUMP);

    vma->vm_page_prot=pgprot_noncached(vma->vm_page_prot);
    if(remap_pfn_range(vma,//虚拟内存区域
                vma->vm_start, //虚拟内存起始地址
                (AXIBASEADDR>>PAGE_SHIFT),//映射区域大小，一般是页大小的倍数
                vma->vm_end - vma->vm_start,
                vma->vm_page_prot))//保护属性
    {
        printk("[kernel] error:ddr address mmap failure!\n");
        return -EAGAIN;
    }
    return 0;
}

#if 0

static long AxiDev_ioctl(struct file *file,unsigned int cmd, unsigned long arg)
{
    struct AXI_EPC_DATA pUser;
    void __iomem* EpcReg;

    memset(&pUser, 0 , sizeof(struct AXI_EPC_DATA));
    if ( copy_from_user(&pUser, (struct AXI_EPC_DATA *)arg, sizeof(struct AXI_EPC_DATA)) )
    {
        printk("[kernel] error:Get User Data failed\n");
        return -EFAULT;
    }

    //check pUser reg value
    if( (pUser.reg < AXI_EPC_0_BASEADDR) ||  (pUser.reg > (AXI_EPC_0_BASEADDR+AXI_EPC_0_LENGTH)) )
    {
        printk("[kernel] error:Reg is not a valid address\n");
        return -2;
    }

    //Get Reg virtual address
    EpcReg = pImageSource->baseaddr + (pUser.reg - AXI_EPC_0_BASEADDR);

    switch(cmd)
    {
        case AXI_EPC_WRITE:
            Xil_Out32(EpcReg, pUser.data);
            break;
        case AXI_EPC_READ:
            pUser.data = Xil_In32(EpcReg);
            if( copy_to_user( (struct AXI_EPC_DATA *)arg, &pUser, sizeof(struct AXI_EPC_DATA) ) )
            {
                printk("[kernel] error:Copy data to user failed\n");
                return -EFAULT;
            }
            break;
        default:
            break;
    }
    return 0;
}

#endif





static struct file_operations AxiDev_fops = {
    .owner = THIS_MODULE,
    .open = AxiDev_open,
    .release = AxiDev_close,
    .mmap = AxiDev_mmap,
};


static int init_Axi(void)
{
    int retval;
    dev_t dev_id;

    if (majorAxi) {
        dev_id = MKDEV(majorAxi, minorAxi);
        retval = register_chrdev_region(dev_id, 1, "XiAxi");
    } else {
        retval = alloc_chrdev_region(&dev_id, 0, 1, "XiAxi");
        majorAxi = MAJOR(dev_id);
    }
    if (retval < 0) {
        goto failure_register_device;
    }

    AxiDev = kmalloc(sizeof(struct image_dev), GFP_KERNEL);
    if (IS_ERR(AxiDev)) {
        retval = PTR_ERR(AxiDev);
        goto failure_kmalloc;
    }
    memset(AxiDev, 0, sizeof(struct image_dev));

    cdev_init(&AxiDev->cdev, &AxiDev_fops);
    retval = cdev_add(&AxiDev->cdev, dev_id, 1);
    if (retval < 0) {
        goto failure_cdev_add;
    }

    AxiDev->cls = class_create(THIS_MODULE, "XiAxi");
    if (IS_ERR(AxiDev->cls)) {
        retval = PTR_ERR(AxiDev->cls);
        goto failure_create_class;
    }

    AxiDev->dev = device_create(AxiDev->cls, NULL, dev_id, NULL, "XiAxi");
    if (IS_ERR(AxiDev->dev)) {
        retval = PTR_ERR(AxiDev->dev);
        goto failure_create_device;
    }

    printk("[kernel] init XiAxi module ok!\n");
    return 0;

failure_create_device:
    class_destroy(AxiDev->cls);
failure_create_class:
    cdev_del(&AxiDev->cdev);
failure_cdev_add:
    kfree(AxiDev);
    AxiDev = NULL;
failure_kmalloc:
    unregister_chrdev_region(dev_id, 1);
failure_register_device:
    return retval;
}


static int exit_Axi(void)
{
    dev_t dev_id = MKDEV(majorAxi, minorAxi);
    device_destroy(AxiDev->cls, dev_id);
    class_destroy(AxiDev->cls);
    cdev_del(&AxiDev->cdev);
    kfree(AxiDev);
    unregister_chrdev_region(dev_id, 1);
    printk("[kernel] remove XiAxi module ok!\n");
    return 0;
}


static int xi_Sensor_init(void)
{
    init_picture();
    init_Axi();
    return 0;
}

static void xi_Sensor_exit(void)
{
    exit_picture();
    exit_Axi();
    return;
}

module_init(xi_Sensor_init);
module_exit(xi_Sensor_exit);

