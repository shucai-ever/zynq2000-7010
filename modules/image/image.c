/*  axi_m_epc.c - The simplest kernel module.
 */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/mm.h>
#include <linux/types.h>
#include <asm/io.h>


#define AXI_EPC_0_BASEADDR 0x40600000U
#define AXI_EPC_0_LENGTH   0x20000U

#define DRIVER_NAME "XiImage"

#define AXI_EPC_WRITE  1
#define AXI_EPC_READ   2<<1
struct AXI_EPC_DATA{
    unsigned int reg;
    unsigned int data;
};

struct image_dev {
    struct device *dev;
    struct cdev cdev;
    void __iomem *baseaddr;
    void __iomem *imageaddr;
};

char *buf = NULL;


/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("zestroly@126.com Inc.");
MODULE_DESCRIPTION("image - loadable module template generated by petalinux-create -t modules");

static struct image_dev *pImageSource = NULL;
static int major = 0;
static int minor = 0;

static struct class *cls;

static u32 Xil_In32(void *Addr)
{
    return *((volatile unsigned int*)(Addr));
}

static void Xil_Out32(void *Addr, u32 Value)
{
    volatile u32 *LoaclAddr = (u32*) Addr;
    *LoaclAddr = Value;
}

static int image_open(struct inode *inode, struct file *file)
{
	return 0;
}

static int image_close(struct inode *inode, struct file *file)
{
    return 0;
}


static long image_ioctl(struct file *file,unsigned int cmd, unsigned long arg)
{
    struct AXI_EPC_DATA pUser;
    void __iomem* EpcReg;

    memset(&pUser, 0 , sizeof(struct AXI_EPC_DATA));
    if ( copy_from_user(&pUser, (struct AXI_EPC_DATA *)arg, sizeof(struct AXI_EPC_DATA)) )
    {
        printk("error:Get User Data failed\n");
        return -EFAULT;
    }

    //check pUser reg value
    if( (pUser.reg < AXI_EPC_0_BASEADDR) ||  (pUser.reg > (AXI_EPC_0_BASEADDR+AXI_EPC_0_LENGTH)) )
    {
        printk("error:Reg is not a valid address\n");
        return -2;
    }

    //Get Reg virtual address
    EpcReg = pImageSource->baseaddr + (pUser.reg - AXI_EPC_0_BASEADDR);

    switch(cmd)
    {
        case AXI_EPC_WRITE:
            Xil_Out32(EpcReg, pUser.data);
            break;
        case AXI_EPC_READ:
            pUser.data = Xil_In32(EpcReg);
            if( copy_to_user( (struct AXI_EPC_DATA *)arg, &pUser, sizeof(struct AXI_EPC_DATA) ) )
            {
                printk("error:Copy data to user failed\n");
                return -EFAULT;
            }
            break;
        default:
            break;
    }
    return 0;
}


static int image_mmap(struct file *file, struct vm_area_struct *vma)
{
    vma->vm_flags |= (VM_IO | VM_DONTEXPAND | VM_DONTDUMP);
    unsigned long vmasize = vma->vm_end - vma->vm_start;

    if(remap_pfn_range(vma,//虚拟内存区域
                vma->vm_start, //虚拟内存起始地址
                vma->vm_pgoff,//映射区域大小，一般是页大小的倍数
                vmasize,
                vma->vm_page_prot))//保护属性
    {
        printk("error mmap\n");
        return -EAGAIN;
    }
    return 0;
}


static struct file_operations image_fops = {
    .owner = THIS_MODULE,
    .open = image_open,
    .release = image_close,
    .unlocked_ioctl = image_ioctl,
    .mmap = image_mmap,
};

static int xi_image_init(void)
{
    int retval;
    dev_t dev_id;


    if (major) {
        dev_id = MKDEV(major, minor);
        retval = register_chrdev_region(dev_id, 1, "XiImage");
    } else {
        retval = alloc_chrdev_region(&dev_id, 0, 1, "XiImage");
        major = MAJOR(dev_id);
    }
    if (retval < 0) {
        goto failure_register_device;
    }

    pImageSource = kmalloc(sizeof(struct image_dev), GFP_KERNEL);
    if (IS_ERR(pImageSource)) {
        retval = PTR_ERR(pImageSource);
        goto failure_kmalloc;
    }
    memset(pImageSource, 0, sizeof(struct image_dev));

    cdev_init(&pImageSource->cdev, &image_fops);
    retval = cdev_add(&pImageSource->cdev, dev_id, 1);
    if (retval < 0) {
        goto failure_cdev_add;
    }

    cls = class_create(THIS_MODULE, "XiImage");
    if (IS_ERR(cls)) {
        retval = PTR_ERR(cls);
        goto failure_create_class;
    }

    pImageSource->dev = device_create(cls, NULL, dev_id, NULL, "Image_m");
    if (IS_ERR(pImageSource->dev)) {
        retval = PTR_ERR(pImageSource->dev);
        goto failure_create_device;
    }

    if (request_mem_region(AXI_EPC_0_BASEADDR, AXI_EPC_0_LENGTH, "XiImage") == NULL) {
        goto failure_request_mem_region;
    }

    pImageSource->baseaddr  = ioremap(AXI_EPC_0_BASEADDR, AXI_EPC_0_LENGTH);
    if (!pImageSource->baseaddr) {
        goto failure_ioremap;
    }
    printk("init XiImage module ok! Compiled: line %d. \n", __LINE__);

    return 0;

failure_ioremap:
    release_mem_region(AXI_EPC_0_BASEADDR, AXI_EPC_0_LENGTH);
failure_request_mem_region:
    device_destroy(cls , dev_id);
failure_create_device:
    class_destroy(cls);
failure_create_class:
    cdev_del(&pImageSource->cdev);
failure_cdev_add:
    kfree(pImageSource);
    pImageSource = NULL;
failure_kmalloc:
    unregister_chrdev_region(dev_id, 1);
failure_register_device:
    return retval;
}

static void xi_image_exit(void)
{
    dev_t dev_id = MKDEV(major, minor);

    iounmap(pImageSource->baseaddr);
    release_mem_region(AXI_EPC_0_BASEADDR, AXI_EPC_0_LENGTH);
    device_destroy(cls, dev_id);
    class_destroy(cls);
    cdev_del(&pImageSource->cdev);
    kfree(pImageSource);
    unregister_chrdev_region(dev_id, 1);
    printk("remove XiImage module ok!\n");
}

module_init(xi_image_init);
module_exit(xi_image_exit);

